# -*- coding: utf-8 -*-
"""DSA_week_1_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ic0UNg74CDCzRmQ3HBKoiclFRknzLrtB

# write prime number
"""

def factor(n):
  factorList = []
  for i in range(1,n+1):
    if n%i == 0:
      factorList.append(i)
  return factorList

def prime(n):
  return(len(factor(n)) == 2)

primeList = []
for i in range(1,101):
  print(i)
  if prime(i):
    primeList.append(i)

(primeList)

"""# week_1_lec2
# find gratest common factor

"""

def gdf(m,n):
  comman_factor = []
  for i in range(1,min(m,n) + 1):
    if m%i == 0 and n%i == 0:
      comman_factor.append(i)
  return comman_factor[-1]

gdf(5,25)

"""## week_1 lec4
## optimisation in prime number

"""

import math
# if we see the above prime number funtion it always go from 1, to n that means if we check 100 then always go from 1 to n so there complexity = 1 + 2 + 3 + ....+ n
# tc = O(n/2 (n+1)) i.e = O(n^2) so we need to optimize
# using for loop

def prime1(n):
  result = True # assume int is prime
  for i in (2,n):
    if n%i == 0:
      result = False
      # because leat prime number is 2 and last prime factor is itself n then we need to iterate n-1
  return result


  ## optimisation of above for loop in this if we found any factor other than 1 and itself then it is not a prime
  def prime2(n):
    result = True
    for i in (2,n):
      if n%i == 0:
        result = False
        break
    return result


    ## using for loop for this we know that the factor's are related suppose factor of 10 is , first factor is 2 then 10/2 = 5 is also factor of 10
    ## that means we need to check factor less than sq.root(n)

    def prime3(n):
      result,i = True,1
      while(result and i < math.math.sqrt(n)):
        if n%i == 0 :
          result = False
        i = i+ 1
      return result

"""# week1 lec 5
# optimisation of gcd
"""

## above algo gives complexity O(min(m,n))
## if m and n have common multiple then it must divide by d
## so m = a*d and n = b*d , then if m - n = ab - bd = (a-b)d it prove that max - min is also divisible by d
# we use recursion here
def gcd1(m,n):
  a,b = max(m,n),min(m,n)
  if a%b == 0 :
    return b
  else:
    gcd1(b,b-a)

## but above algo takes max(m,n) which is grater than privious then we use Euclids algo
## if n is not divide m then m = nq + r ------(1) means after devide m by n some remainder reamin
## suppose m = ad and n = bd then replace this in eq 1
## we got ad = bdq + r  , if in lhs we have some factor d then in rhs also we have facor d so r must be r = cd
## insted of a-b we use a%b
def gcd3(m,n):
  a,b = max(m,n),min(m,n)
  if a%b == 0 :
    return b
  else:
    gcd1(b,a%b)

"""## week 1 lec 6
## error handling
"""



"""Week 1 lec 10
timer class and funtion
"""

import time
class ExceptionTimer(Exception):
  '''Custom error'''
class Timer:
  def __init__(self):
    self._start_time = None
    self._elapsed_time = None

  def start(self):
    if self._start_time is not None:
      raise Exception("Timer is running")
    self._start_time = time.perf_counter()

  def end(self):
    if self._start_time is None:
      raise ExceptionTimer("Timmer not start")
    self._elapsed_time = time.perf_counter() - self._start_time
    self._start_time = None


  def elapsed(self):
    if self._elapsed_time is None:
      raise ExceptionTimer("Timer have not been start yet, start timer")
    return self._elapsed_time

  def __str__(self):
    "print( the string)"
    return (str(self._elapsed_time))

## test timer
t = Timer()
n = 0
for j in range(4,9):
  t.start()
  for i in range(10**j):
    n = n+i
  t.end()
  print(j,t)